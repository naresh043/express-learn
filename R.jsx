import React, { forwardRef, useImperativeHandle, useState, useRef, useEffect, } from "react"; import { useDispatch, useSelector } from "react-redux"; import { TextField } from "@mui/material"; import { SetUIChangedList, SetvalidationformState, setForcedValidation, } from "../../ReduxSlices/DynamicSlices"; import { getYupSchema } from "../../SchemaFolder/validationsSchema"; import FormHelperText from "@mui/material/FormHelperText"; import FormControl from "@mui/material/FormControl"; import { UseFetchedFormate } from "../../FunctionalityFolder/config"; export const TextFieldComponent = forwardRef( ( { values, label, empty, readOnly = false, onChange, error, // from parent (optional) prop = "value", helperText, style, mainExtension, index, setFormValues, setErrors, mask, ElementList, refs, visible = true, yupcondition, children, initialValidation, }, ref ) => { const dispatch = useDispatch(); const [internalText, setInternalText] = useState(""); const [internalError, setInternalError] = useState(""); const [visibleState, setVisibleState] = useState(visible); const [yupConditionState, setYupConditionState] = useState(); const [elementListState, setElementListState] = useState(null); const hasUserTyped = useRef(false); useEffect(() => { const val = Array.isArray(visible) ? visible[0] : visible; const boolVal = typeof val === "string" ? val.toLowerCase() === "true" : Boolean(val); setVisibleState(boolVal); }, [visible]); const ForcedValidation = useSelector( (state) => state.containers?.ForcedValidation?.[mainExtension] ?? false ); const validateValue = async (value) => { // âœ… Skip validation if not visible if (!visibleState) { console.log( â­ï¸ Skipping validation for index ${index}, field not visible ); setInternalError(""); dispatch( SetvalidationformState({ id: mainExtension, index: index, value: true, }) ); return true; } const activeList = elementListState || ElementList; const elementObject = activeList.find((item) => item.index === index); if (!elementObject) return true; console.log("ðŸ”Ž Validating elementObject", elementObject); const schema = getYupSchema(elementObject, refs, activeList, prop); if (!schema) return true; try { await schema.validate({ [index]: value }); setInternalError(""); dispatch( SetvalidationformState({ id: mainExtension, index: index, value: true, }) ); return true; } catch (err) { setInternalError(err.message); dispatch( SetvalidationformState({ id: mainExtension, index: index, value: false, }) ); return false; } }; useEffect(() => { if (initialValidation) { const activeList = elementListState || ElementList; // â­ï¸ Skip when not visible if (!visibleState) { console.log( â­ï¸ Skipping re-validation for index ${index}, not visible ); return; } if (activeList && internalText !== undefined) { console.log( â™»ï¸ Re-validating index ${index} after schema update or mount ); validateValue(internalText); } } }, [elementListState, ElementList, internalText, index, visibleState]); useEffect(() => { if (initialValidation) { const initialVal = values || internalText || ""; if (!visibleState) { console.log( â­ï¸ Skipping initial validation for index ${index}, not visible ); setInternalError(""); dispatch( SetvalidationformState({ id: mainExtension, index, value: true }) ); return; } console.log(âœ… Running initial validation for index ${index}); validateValue(initialVal); } }, [index, visibleState]); useEffect(() => { if (ForcedValidation) { const initialVal = internalText || ""; if (visibleState) { console.log("ForcedValidation triggered with initialVal", initialVal); validateValue(initialVal); } else { setInternalError(""); dispatch( setForcedValidation({ id: mainExtension, index: index, value: true, }) ); } dispatch(setForcedValidation({ id: mainExtension, value: false })); } }, [ForcedValidation, visibleState]); useEffect(() => { if (!hasUserTyped.current && values !== undefined) { setInternalText(values); console.log( âœ… Initial value set from props at index ${index}:, values ); } }, [values, index]); const handleChange = async (e) => { const newValue = e.target.value; hasUserTyped.current = true; setInternalText(newValue); if (onChange) onChange(e); }; const handleBlur = async () => { const isValid = await validateValue(internalText); if (isValid) { setFormValues((prev) => ({ ...prev, [index]: internalText })); setErrors((prev) => { const { [index]: _, ...rest } = prev; return rest; }); } else { setErrors((prev) => ({ ...prev, [index]: internalError })); } dispatch(SetUIChangedList({ mainExtension, index, prop })); console.log( "dataaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", { mainExtension, index, prop } ); }; const getDisplayValue = () => { const text = internalText ?? values ?? ""; return mask ? "*".repeat(text.length) : text; }; useImperativeHandle(ref, () => ({ setProperty: async (propertyName, value) => { console.log("ðŸ’¡ setProperty called:", propertyName, value); if (propertyName === "value") { if (hasUserTyped.current) { console.log(ðŸ”’ value blocked at index ${index}, user has typed); return; } if (!empty) { const normalizedValue = Array.isArray(value) ? value.join(", ") : value; const fetchdatevalue = await UseFetchedFormate(normalizedValue); setInternalText(fetchdatevalue); const isValid = await validateValue(fetchdatevalue); console.log("ðŸ’¡ Value set:", fetchdatevalue, "Valid?", isValid); } } // HANDLE VISIBLE SEPARATELY if (propertyName === "visible") { const val = Array.isArray(value) ? value[0] : value; const boolVal = typeof val === "string" ? val.toLowerCase() === "true" : Boolean(val); console.log("ðŸ’¡ Visible set:", value, "->", boolVal); setVisibleState(boolVal); } if (propertyName === "yupcondition") { const val = Array.isArray(value) ? value[0] : value; setYupConditionState(val); const patternName = yupPatternMap[val]; if (patternName) { setElementListState((prevList) => { const baseList = prevList || ElementList; // start with normal ElementList if no updates yet const elementIndex = baseList.findIndex( (item) => item.index === index ); if (elementIndex === -1) return baseList; const updatedElement = { ...baseList[elementIndex], validation: { ...(baseList[elementIndex].validation || {}), patternName, }, }; const newList = [...baseList]; newList[elementIndex] = updatedElement; console.log( âœ… Injected patternName "${patternName}" for index ${index}, updatedElement ); return newList; }); // re-validate current value with updated schema validateValue(internalText); } } //epic 2 //adhar 1 //pan 5 }, getProperty(propertyName) { if (propertyName === "value") { return internalText; } else if (propertyName === "yupcondition") { return yupConditionState; } else if (propertyName === "visible") { return visibleState; } }, unlock() { hasUserTyped.current = false; console.log(ðŸ”“ Manual unlock for index ${index}); }, })); const yupPatternMap = { 1: "aadhaar", 2: "voterId", 5: "pan", }; // if (!visible) return null; if (!visibleState) return null; return ( <> <FormControl fullWidth error={!!internalError} className="my-form-control" sx={{ marginBottom: "0px !important", }} > <TextField value={getDisplayValue()} label={label || ""} id={index} onChange={handleChange} onBlur={handleBlur} variant="outlined" error={!!internalError} className="my-form-control css-1kg4btv-MuiFormControl-root-MuiTextField-root" style={style} sx={{ mb: 2, width: style?.width || "100%", "& .MuiOutlinedInput-root": { "& fieldset": { ...(style?.fieldset || {}), // special styles for border }, "&:hover fieldset": { ...(style?.fieldset || {}), }, "&.Mui-focused fieldset": { ...(style?.fieldset || {}), }, }, "& .MuiOutlinedInput-input": { height: "1.4375em", padding: "7.5px 14px", }, "& .MuiInputLabel-root": { // This applies only when the label is NOT shrunk "&.MuiInputLabel-root:not(.MuiInputLabel-shrink)": { transform: "translate(20px, 9px)", // move right 8px, down 9px }, }, }} onKeyDown={(e) => { if (e.key === "Enter") { e.preventDefault(); handleBlur(); // âœ” Only run on Enter } }} InputProps={{ sx: { // styles that belonged to .css-16wblaj-MuiInputBase-input-MuiOutlinedInput-input "& .MuiInputBase-input": { color: "rgb(85 81 81 / 87%)", }, height: 38, fontSize: 14, padding: "5.5px 0px", // marginBottom: '-10px !important',a }, inputProps: { readOnly, }, }} /> <FormHelperText>{internalError || helperText}</FormHelperText> </FormControl> </> ); } ); export const CustomTextField = ({ value = "", onChange, error = false, helperText = "", placeholder = "Enter value", style = {}, }) => { return ( <FormControl fullWidth error={error} style={style}> <TextField fullWidth variant="outlined" value={value} placeholder={placeholder} onChange={(e) => onChange(e.target.value)} error={error} /> {error && <FormHelperText>{helperText}</FormHelperText>} </FormControl> ); }; , explain this